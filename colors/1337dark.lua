-- 1337dark.lua â€” minimal onedark-inspired Neovim colorscheme

local hl = vim.api.nvim_set_hl

-- One Dark palette
local p = {
    bg       = "#1e222a",
    bg_alt   = "#21252b",
    fg       = "#abb2bf",
    fg_dark  = "#828997",
    red      = "#e06c75",
    orange   = "#d19a66",
    yellow   = "#e5c07b",
    green    = "#98c379",
    cyan     = "#56b6c2",
    blue     = "#61afef",
    purple   = "#c678dd",
    comment  = "#5c6370",
    gutter   = "#4b5263",
    cursorln = "#2c323c",
    none     = "none",
}

-- Reset highlights to avoid clashes
vim.cmd("highlight clear")
if vim.fn.exists("syntax_on") == 1 then vim.cmd("syntax reset") end
vim.g.colors_name = "1337dark"

hl(0, "Normal", { fg = p.fg, bg = p.none })
hl(0, "NormalNC", { fg = p.fg_dark, bg = p.none })
hl(0, "EndOfBuffer", { fg = p.fg_dark, bg = p.none })
hl(0, "CursorLine", { bg = p.cursorln })
hl(0, "CursorColumn", { bg = p.cursorln })
hl(0, "ColorColumn", { bg = p.cursorln })
hl(0, "CursorLineNr", { fg = p.yellow, bold = true })
hl(0, "LineNr", { fg = p.gutter })
hl(0, "SignColumn", { bg = p.bg })
hl(0, "VertSplit", { fg = p.bg_alt })
hl(0, "StatusLine", { fg = p.fg, bg = p.bg_alt })
hl(0, "StatusLineNC", { fg = p.comment, bg = p.bg_alt })
hl(0, "WinSeparator", { fg = p.bg_alt })

-- UI elements
hl(0, "Pmenu", { fg = p.fg, bg = p.bg_alt })
hl(0, "PmenuSel", { fg = p.bg, bg = p.blue })
hl(0, "PmenuSbar", { bg = p.bg_alt })
hl(0, "PmenuThumb", { bg = p.comment })
hl(0, "Visual", { bg = p.bg_alt })
hl(0, "Search", { fg = p.bg, bg = p.orange })
hl(0, "IncSearch", { fg = p.bg, bg = p.yellow })
hl(0, "MatchParen", { fg = p.yellow, bg = p.bg_alt, bold = true })
hl(0, "Folded", { fg = p.comment, bg = p.bg_alt, italic = true })
hl(0, "FoldColumn", { fg = p.comment, bg = p.bg })

-- Text / syntax
hl(0, "Comment", { fg = p.comment, italic = true })
hl(0, "Constant", { fg = p.cyan })
hl(0, "String", { fg = p.green })
hl(0, "Character", { fg = p.green })
hl(0, "Number", { fg = p.orange })
hl(0, "Boolean", { fg = p.orange })
hl(0, "Identifier", { fg = p.red })
hl(0, "Function", { fg = p.blue })
hl(0, "Statement", { fg = p.purple })
hl(0, "Keyword", { fg = p.purple })
hl(0, "Conditional", { fg = p.purple })
hl(0, "Repeat", { fg = p.purple })
hl(0, "Operator", { fg = p.fg })
hl(0, "Type", { fg = p.yellow })
hl(0, "StorageClass", { fg = p.yellow })
hl(0, "Structure", { fg = p.yellow })
hl(0, "Special", { fg = p.orange })
hl(0, "Underlined", { fg = p.cyan, underline = true })
hl(0, "Todo", { fg = p.purple, bold = true })
hl(0, "Error", { fg = p.red, bold = true })

-- Diagnostics
hl(0, "DiagnosticError", { fg = p.red })
hl(0, "DiagnosticWarn", { fg = p.yellow })
hl(0, "DiagnosticInfo", { fg = p.blue })
hl(0, "DiagnosticHint", { fg = p.cyan })
hl(0, "DiagnosticUnderlineError", { undercurl = true, sp = p.red })
hl(0, "DiagnosticUnderlineWarn", { undercurl = true, sp = p.yellow })
hl(0, "DiagnosticUnderlineInfo", { undercurl = true, sp = p.blue })
hl(0, "DiagnosticUnderlineHint", { undercurl = true, sp = p.cyan })

-- Diff / git
hl(0, "DiffAdd", { fg = p.green, bg = p.none })
hl(0, "DiffDelete", { fg = p.red, bg = p.none })
hl(0, "DiffChange", { fg = p.yellow, bg = p.none })
hl(0, "DiffText", { fg = p.blue, bg = p.none })

-- LSP / Treesitter link groups (basic)
hl(0, "@function", { link = "Function" })
hl(0, "@keyword", { link = "Keyword" })
hl(0, "@string", { link = "String" })
hl(0, "@comment", { link = "Comment" })
hl(0, "@type", { link = "Type" })
hl(0, "@variable", { fg = p.fg })

-- End of personal scheme

-- HACK: Mostly generated by ChatGPT, need to go through and fix. A little buggy,
-- but gets the job done.
--------------------------------------------------------------------------------
-- Comment tag highlights (plugin-free, token-only) + Tree-sitter incremental
-- - Highlights ONLY the tag tokens (e.g. "TODO: ") when inside comments
-- - Uses TS on_changedtree for near-keystroke updates when available
-- - Falls back to simple autocmd-based refresh when no TS parser exists
--------------------------------------------------------------------------------
do
    local api = vim.api
    local ns  = api.nvim_create_namespace("1337.comment_tags")

    -- (1) Define Tag* highlight groups using your palette `p`
    local function define_hls()
        api.nvim_set_hl(0, "TagTODO", { fg = p.purple, bold = true })
        api.nvim_set_hl(0, "TagTEST", { fg = p.cyan, bold = true })
        api.nvim_set_hl(0, "TagPASS", { fg = p.green, bold = true })
        api.nvim_set_hl(0, "TagPERF", { fg = p.green, bold = true })
        api.nvim_set_hl(0, "TagFAIL", { fg = p.red, bold = true })
        api.nvim_set_hl(0, "TagWARN", { fg = p.orange, bold = true })
        api.nvim_set_hl(0, "TagNOTE", { fg = p.blue, bold = true })
    end
    define_hls()

    -- (2) Tokens to search; highlight ONLY these literal substrings
    --     (keep your trailing spaces exactly as you want them highlighted)
    local TAGS = {
        {
            hl = "TagTODO",
            words = {
                "TODO: ", -- TODO: Leave a comment for something you need to get done.
                "LLO: ", -- LLO: last left off.
                "START: ", -- START: starts/go here first
                "END: ", -- END: ends/go here last
                "HERE: ", -- HERE: go here
            }
        },
        {
            hl = "TagTEST",
            words = {
                "TEST: ", -- TEST: testing or test
                "EXP: ", -- EXP: experimental block
                "TEMP: ", -- TEMP: this is temporary
            }
        },
        {
            hl = "TagPASS",
            words = {
                "PASS: ", -- PASS: passing test
            }
        },
        {
            hl = "TagPERF",
            words = {
                "PERF: ", -- PERF: performance block
                "OPTIM: ", -- OPTIM: optimized/optimal/ or optimization block
            }
        },
        {
            hl = "TagFAIL",
            words = {
                "FAIL: ", -- FAIL: Failed block
                "ERROR: ", -- ERROR: This probably breaks things
                "FIXME: ", -- FIXME: please?
                "BUG: ", -- BUG: Eww, squish it!
            }
        },
        {
            hl = "TagWARN",
            words = {
                "WARNING: ", -- WARNING: You have been warned...
                "HACK: ", -- HACK: This was hacked up!
                "CAUTION: ", -- CAUTION: Proceed with caution, ok?
            }
        },
        {
            hl = "TagNOTE",
            words = {
                "NOTE: ", -- NOTE: Small note info.
                "INFO: ", -- INFO: General info.
                "NEW: ", -- NEW: New info.
                "OLD: ", -- OLD: old info.
            }
        },
    }

    -- (3) Is (row,col) inside a comment? Prefer Tree-sitter; fall back to :syntax
    local function in_comment(buf, row, col)
        if vim.treesitter and vim.treesitter.get_captures_at_pos then
            local ok, caps = pcall(vim.treesitter.get_captures_at_pos, buf, row, col)
            if ok and caps then
                for _, cap in ipairs(caps) do
                    local name = (type(cap) == "table") and cap.capture or cap
                    if type(name) == "string" and name:lower():find("comment", 1, true) then
                        return true
                    end
                end
            end
        end
        local id  = vim.fn.synID(row + 1, col + 1, 1)
        local tid = vim.fn.synIDtrans(id)
        local nm  = vim.fn.synIDattr(tid, "name")
        return type(nm) == "string" and nm:lower():find("comment", 1, true) ~= nil
    end

    -- (4) Range-based scan & highlight (clears + repaints only the range)
    local function refresh_range(buf, srow, erow)
        buf = buf or 0
        if not api.nvim_buf_is_loaded(buf) then return end

        local last = math.max(0, api.nvim_buf_line_count(buf) - 1)
        srow = math.max(0, tonumber(srow) or 0)
        erow = (erow == nil or erow < 0) and last or math.min(tonumber(erow) or last, last)

        api.nvim_buf_clear_namespace(buf, ns, srow, erow + 1)
        local lines = api.nvim_buf_get_lines(buf, srow, erow + 1, false)

        for i, line in ipairs(lines) do
            local row = srow + i - 1
            for _, tag in ipairs(TAGS) do
                for _, word in ipairs(tag.words) do
                    local init = 1
                    while true do
                        local s, e = string.find(line, word, init, true) -- plain search
                        if not s then break end
                        local col0 = s - 1
                        if in_comment(buf, row, col0) then
                            api.nvim_buf_add_highlight(buf, ns, tag.hl, row, col0, col0 + #word)
                        end
                        init = e + 1
                    end
                end
            end
        end
    end

    -- (5) Full-buffer repaint helper
    local function refresh(buf)
        buf = buf or 0
        refresh_range(buf, 0, -1)
    end

    -- (6) Tree-sitter incremental updates (robust across change shapes)
    local UINT_MAX = 0xFFFFFFFF
    local function handle_ts_changes(buf, changes)
        local minr, maxr = math.huge, -1
        local lastrow    = math.max(0, api.nvim_buf_line_count(buf) - 1)

        for _, ch in ipairs(changes or {}) do
            local sr, er
            if type(ch[1]) == "table" and type(ch[2]) == "table" then
                -- { {sr,sc,sb}, {er,ec,eb} }
                sr = ch[1][1] or 0
                er = ch[2][1] or sr
            else
                -- { sr, sc, [sb], er, ec, [eb] }  (sometimes 4 ints, sometimes 6)
                sr = ch[1] or 0
                er = ch[4] or ch[3] or sr
                -- Full-buffer sentinel -> normalize to whole buffer
                if type(er) == "number" and er >= UINT_MAX / 2 then
                    sr, er = 0, lastrow
                end
            end
            sr = math.max(0, math.min(sr, lastrow))
            er = math.max(sr, math.min(er, lastrow))
            if sr < minr then minr = sr end
            if er > maxr then maxr = er end
        end

        if minr == math.huge then
            refresh_range(buf, 0, -1)
        else
            refresh_range(buf, minr, maxr)
        end
    end

    local function attach_ts(buf)
        define_hls()
        -- Start TS highlighter so on_changedtree fires during edits
        pcall(vim.treesitter.start, buf)
        -- Initial paint
        refresh_range(buf, 0, -1)

        local ok, parser = pcall(vim.treesitter.get_parser, buf)
        if not ok or not parser then return end

        parser:register_cbs({
            on_changedtree = function(changes, _)
                vim.schedule(function()
                    if api.nvim_buf_is_valid(buf) then
                        handle_ts_changes(buf, changes)
                    end
                end)
            end,
        })
    end

    -- (7) Manual command
    api.nvim_create_user_command("CommentTagsRefresh", function()
        refresh(0)
    end, { desc = "Refresh comment tag highlights (token-only)" })

    -- (8) Attach TS when possible; else fall back to simple autocmd refresh
    local grp_ts = api.nvim_create_augroup("1337.comment_tags_ts", { clear = true })
    api.nvim_create_autocmd({ "BufEnter", "FileType" }, {
        group = grp_ts,
        callback = function(args)
            if vim.b[args.buf].comment_tags_ts_attached then return end
            local ok = pcall(vim.treesitter.get_parser, args.buf)
            if not ok then return end
            vim.b[args.buf].comment_tags_ts_attached = true
            attach_ts(args.buf)
        end,
    })

    local grp_fb = api.nvim_create_augroup("1337.comment_tags_fallback", { clear = true })
    api.nvim_create_autocmd({ "BufEnter", "TextChanged", "InsertLeave", "BufWritePost" }, {
        group = grp_fb,
        callback = function(args)
            if vim.b[args.buf].comment_tags_ts_attached then return end -- TS will handle it
            define_hls()
            refresh(args.buf)
        end
    })

    -- Reapply groups & repaint on colorscheme reload
    api.nvim_create_autocmd("ColorScheme", {
        group = grp_fb,
        callback = function()
            define_hls()
            if api.nvim_buf_is_valid(0) then refresh(0) end
        end,
    })

    -- Initial apply for current buffer
    refresh(0)
end
