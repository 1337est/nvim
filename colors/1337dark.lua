-- 1337dark.lua â€” minimal onedark-inspired Neovim colorscheme

local hl = vim.api.nvim_set_hl

-- One Dark palette
local p = {
    bg       = "#1e222a",
    bg_alt   = "#21252b",
    fg       = "#abb2bf",
    fg_dark  = "#828997",
    red      = "#e06c75",
    orange   = "#d19a66",
    yellow   = "#e5c07b",
    green    = "#98c379",
    cyan     = "#56b6c2",
    blue     = "#61afef",
    purple   = "#c678dd",
    comment  = "#5c6370",
    gutter   = "#4b5263",
    cursorln = "#2c323c",
    none     = "none",
}

-- Reset highlights to avoid clashes
vim.cmd("highlight clear")
if vim.fn.exists("syntax_on") == 1 then vim.cmd("syntax reset") end
vim.g.colors_name = "1337dark"

hl(0, "Normal", { fg = p.fg, bg = p.none })
hl(0, "NormalNC", { fg = p.fg_dark, bg = p.none })
hl(0, "EndOfBuffer", { fg = p.fg_dark, bg = p.none })
hl(0, "CursorLine", { bg = p.cursorln })
hl(0, "CursorColumn", { bg = p.cursorln })
hl(0, "ColorColumn", { bg = p.cursorln })
hl(0, "CursorLineNr", { fg = p.yellow, bold = true })
hl(0, "LineNr", { fg = p.gutter })
hl(0, "SignColumn", { bg = p.bg })
hl(0, "VertSplit", { fg = p.bg_alt })
hl(0, "StatusLine", { fg = p.fg, bg = p.bg_alt })
hl(0, "StatusLineNC", { fg = p.comment, bg = p.bg_alt })
hl(0, "WinSeparator", { fg = p.bg_alt })

-- UI elements
hl(0, "Pmenu", { fg = p.fg, bg = p.bg_alt })
hl(0, "PmenuSel", { fg = p.bg, bg = p.blue })
hl(0, "PmenuSbar", { bg = p.bg_alt })
hl(0, "PmenuThumb", { bg = p.comment })
hl(0, "Visual", { bg = p.bg_alt })
hl(0, "Search", { fg = p.bg, bg = p.orange })
hl(0, "IncSearch", { fg = p.bg, bg = p.yellow })
hl(0, "MatchParen", { fg = p.yellow, bg = p.bg_alt, bold = true })
hl(0, "Folded", { fg = p.comment, bg = p.bg_alt, italic = true })
hl(0, "FoldColumn", { fg = p.comment, bg = p.bg })

-- Text / syntax
hl(0, "Comment", { fg = p.comment, italic = true })
hl(0, "Constant", { fg = p.cyan })
hl(0, "String", { fg = p.green })
hl(0, "Character", { fg = p.green })
hl(0, "Number", { fg = p.orange })
hl(0, "Boolean", { fg = p.orange })
hl(0, "Identifier", { fg = p.red })
hl(0, "Function", { fg = p.blue })
hl(0, "Statement", { fg = p.purple })
hl(0, "Keyword", { fg = p.purple })
hl(0, "Conditional", { fg = p.purple })
hl(0, "Repeat", { fg = p.purple })
hl(0, "Operator", { fg = p.fg })
hl(0, "Type", { fg = p.yellow })
hl(0, "StorageClass", { fg = p.yellow })
hl(0, "Structure", { fg = p.yellow })
hl(0, "Special", { fg = p.orange })
hl(0, "Underlined", { fg = p.cyan, underline = true })
hl(0, "Todo", { fg = p.purple, bold = true })
hl(0, "Error", { fg = p.red, bold = true })

-- Diagnostics
hl(0, "DiagnosticError", { fg = p.red })
hl(0, "DiagnosticWarn", { fg = p.yellow })
hl(0, "DiagnosticInfo", { fg = p.blue })
hl(0, "DiagnosticHint", { fg = p.cyan })
hl(0, "DiagnosticUnderlineError", { undercurl = true, sp = p.red })
hl(0, "DiagnosticUnderlineWarn", { undercurl = true, sp = p.yellow })
hl(0, "DiagnosticUnderlineInfo", { undercurl = true, sp = p.blue })
hl(0, "DiagnosticUnderlineHint", { undercurl = true, sp = p.cyan })

-- Diff / git
hl(0, "DiffAdd", { fg = p.green, bg = p.none })
hl(0, "DiffDelete", { fg = p.red, bg = p.none })
hl(0, "DiffChange", { fg = p.yellow, bg = p.none })
hl(0, "DiffText", { fg = p.blue, bg = p.none })

-- LSP / Treesitter link groups (basic)
hl(0, "@function", { link = "Function" })
hl(0, "@keyword", { link = "Keyword" })
hl(0, "@string", { link = "String" })
hl(0, "@comment", { link = "Comment" })
hl(0, "@type", { link = "Type" })
hl(0, "@variable", { fg = p.fg })

-- End of personal scheme

-- HACK: Mostly generated by ChatGPT, need to go through and fix. A little buggy,
-- but gets the job done.
--------------------------------------------------------------------------------
-- Comment tag highlights (plugin-free, token-only, TS-aware)
-- Highlights only the tag (e.g. "TODO: ") when it is inside a comment.
--------------------------------------------------------------------------------
do
    local api = vim.api
    local ns = vim.api.nvim_create_namespace("1337.comment_tags")

    -- Define tag highlight groups
    api.nvim_set_hl(0, "TagTODO", { link = "Todo" })
    api.nvim_set_hl(0, "TagTEST", { fg = p.cyan, bold = true })
    api.nvim_set_hl(0, "TagPASS", { fg = p.green, bold = true })
    api.nvim_set_hl(0, "TagPERF", { fg = p.green, bold = true })
    api.nvim_set_hl(0, "TagFAIL", { fg = p.red, bold = true })
    api.nvim_set_hl(0, "TagWARN", { fg = p.orange, bold = true })
    api.nvim_set_hl(0, "TagNOTE", { fg = p.blue, bold = true })

    -- Tokens to search (uppercase, ASCII); highlight ONLY these substrings
    local TAGS = {
        {
            hl = "TagTODO",
            words = {
                "TODO: ", -- TODO: Leave a comment for something you need to get done.
                "LLO: ", -- LLO: last left off.
                "START: ", -- START: starts/go here first
                "END: ", -- END: ends/go here last
                "HERE: ", -- HERE: go here
            }
        },
        {
            hl = "TagTEST",
            words = {
                "TEST: ", -- TEST: testing or test
                "EXP: ", -- EXP: experimental block
                "TEMP: ", -- TEMP: this is temporary
            }
        },

        {
            hl = "TagPASS",
            words = {
                "PASS: ", -- PASS: passing test
            }
        },

        {
            hl = "TagPERF",
            words = {
                "PERF: ", -- PERF: performance block
                "OPTIM: ", -- OPTIM: optimized/optimal/ or optimization block
            }
        },

        {
            hl = "TagFAIL",
            words = {
                "FAIL: ", -- FAIL: Failed block
                "ERROR: ", -- ERROR: This probably breaks things
                "FIXME: ", -- FIXME: please?
                "BUG: ", -- BUG: Eww, squish it!
            }
        },

        {
            hl = "TagWARN",
            words = {
                "WARNING: ", -- WARNING: You have been warned...
                "HACK: ", -- HACK: This was hacked up!
                "CAUTION: ", -- CAUTION: Proceed with caution, ok?
            }
        },

        {
            hl = "TagNOTE",
            words = {
                "NOTE: ", -- NOTE: Small note info.
                "INFO: ", -- INFO: General info.
                "NEW: ", -- NEW: New info.
                "OLD: ", -- OLD: old info.
            }
        },

    }

    -- Is (row,col) inside a comment? Prefer Tree-sitter; fall back to :syntax
    local function in_comment(buf, row, col)
        if vim.treesitter and vim.treesitter.get_captures_at_pos then
            local ok, caps = pcall(vim.treesitter.get_captures_at_pos, buf, row, col)
            if ok and caps then
                for _, cap in ipairs(caps) do
                    local name = (type(cap) == "string") and cap or cap.capture or cap.name
                    if type(name) == "string" and name:lower():find("comment") then
                        return true
                    end
                end
            end
        end
        local id  = vim.fn.synID(row + 1, col + 1, 1)
        local tid = vim.fn.synIDtrans(id)
        local nm  = vim.fn.synIDattr(tid, "name")
        return type(nm) == "string" and nm:lower():find("comment") ~= nil
    end

    -- Scan buffer and add token-only highlights
    local function refresh(buf)
        buf = buf or 0
        if not vim.api.nvim_buf_is_loaded(buf) then return end
        vim.api.nvim_buf_clear_namespace(buf, ns, 0, -1)

        local lines = vim.api.nvim_buf_get_lines(buf, 0, -1, false)
        for i, line in ipairs(lines) do
            local row = i - 1
            for _, tag in ipairs(TAGS) do
                for _, word in ipairs(tag.words) do
                    local init = 1
                    while true do
                        local s, e = string.find(line, word, init, true) -- plain find (no patterns)
                        if not s then break end
                        local col0 = s - 1 -- 0-based column
                        if in_comment(buf, row, col0) then
                            vim.api.nvim_buf_add_highlight(buf, ns, tag.hl, row, col0, col0 + #word)
                        end
                        init = e + 1
                    end
                end
            end
        end
    end

    -- Manual refresh command
    vim.api.nvim_create_user_command("CommentTagsRefresh", function()
        refresh(0)
    end, { desc = "Refresh comment tag highlights (token-only)" })

    -- Auto-apply on common events
    local grp = vim.api.nvim_create_augroup("1337.comment_tags", { clear = true })
    vim.api.nvim_create_autocmd(
        { "BufEnter", "TextChanged", "InsertLeave", "BufWritePost", "ColorScheme" },
        {
            group = grp,
            callback = function(args)
                -- re-apply Tag* groups in case colorscheme was reloaded
                vim.api.nvim_set_hl(0, "TagTODO", { link = "Todo" })
                vim.api.nvim_set_hl(0, "TagTEST", { fg = p.cyan, bold = true })
                vim.api.nvim_set_hl(0, "TagPASS", { fg = p.green, bold = true })
                vim.api.nvim_set_hl(0, "TagPERF", { fg = p.green, bold = true })
                vim.api.nvim_set_hl(0, "TagFAIL", { fg = p.red, bold = true })
                vim.api.nvim_set_hl(0, "TagWARN", { fg = p.orange, bold = true })
                vim.api.nvim_set_hl(0, "TagNOTE", { fg = p.blue, bold = true })
                refresh(args.buf)
            end
        }
    )

    -- Initial apply
    refresh(0)
end
